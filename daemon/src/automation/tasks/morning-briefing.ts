/**
 * Morning Briefing â€” sends the human a daily summary.
 *
 * Gathers: calendar events, weather, open todos, overnight messages.
 * If a Claude session is active, injects data as a prompt for a nicely
 * formatted briefing. If no session, sends a plain-text version directly
 * via Telegram so the briefing always arrives on time.
 */

import { execSync, execFileSync } from 'node:child_process';
import fs from 'node:fs';
import path from 'node:path';
import { injectText, sessionExists } from '../../core/session-bridge.js';
import { createLogger } from '../../core/logger.js';
import { getProjectDir, loadConfig } from '../../core/config.js';
import { registerTask } from '../scheduler.js';
import { sendMessage as sendTelegramMessage } from '../../comms/adapters/telegram.js';
import { checkAllUnread } from '../../comms/adapters/email/index.js';

const log = createLogger('morning-briefing');

/** Check if today is a holiday or special day, return a themed greeting or null. */
function getSpecialDayNote(): string | null {
  const now = new Date();
  const month = now.getMonth() + 1;
  const day = now.getDate();
  const dow = now.getDay(); // 0=Sun

  // Fixed-date holidays
  const fixed: Record<string, string> = {
    '1-1': 'ðŸŽ‰ Happy New Year!',
    '2-14': 'ðŸ’• Happy Valentine\'s Day!',
    '3-17': 'â˜˜ï¸ Happy St. Patrick\'s Day!',
    '7-4': 'ðŸ‡ºðŸ‡¸ Happy Independence Day!',
    '10-31': 'ðŸŽƒ Happy Halloween!',
    '11-11': 'ðŸŽ–ï¸ Veterans Day â€” thank a veteran today.',
    '12-24': 'ðŸŽ„ Christmas Eve!',
    '12-25': 'ðŸŽ„ Merry Christmas!',
    '12-31': 'ðŸ¥‚ Happy New Year\'s Eve!',
  };

  const key = `${month}-${day}`;
  if (fixed[key]) return fixed[key];

  // Floating holidays (day-of-week + week-in-month rules)
  if (month === 1 && dow === 1 && day >= 15 && day <= 21) return 'ðŸ•Šï¸ Martin Luther King Jr. Day';
  if (month === 2 && dow === 1 && day >= 15 && day <= 21) return 'ðŸ›ï¸ Presidents\' Day';
  if (month === 5 && dow === 0 && day >= 8 && day <= 14) return 'ðŸ’ Happy Mother\'s Day!';
  if (month === 5 && dow === 1 && day >= 25) return 'ðŸ‡ºðŸ‡¸ Memorial Day â€” remember those who served.';
  if (month === 6 && dow === 0 && day >= 15 && day <= 21) return 'ðŸ‘” Happy Father\'s Day!';
  if (month === 9 && dow === 1 && day <= 7) return 'ðŸ”¨ Happy Labor Day!';
  if (month === 11 && dow === 4 && day >= 22 && day <= 28) return 'ðŸ¦ƒ Happy Thanksgiving!';

  return null;
}

function gatherCalendar(): string {
  try {
    const output = execSync(
      'icalbuddy -n -nc -nrd -npn -ea -eep notes,url -df "%A, %b %e, %Y" -b "â€¢ " -iep title,datetime,attendees eventsToday',
      { encoding: 'utf8', timeout: 10_000 },
    ).trim();
    return output || 'No events today.';
  } catch {
    log.warn('icalbuddy failed or not available');
    return 'Calendar unavailable.';
  }
}

/** WMO weather interpretation codes â†’ human-readable descriptions */
const WMO_CODES: Record<number, string> = {
  0: 'Clear', 1: 'Mostly clear', 2: 'Partly cloudy', 3: 'Overcast',
  45: 'Foggy', 48: 'Rime fog',
  51: 'Light drizzle', 53: 'Drizzle', 55: 'Heavy drizzle',
  56: 'Light freezing drizzle', 57: 'Freezing drizzle',
  61: 'Light rain', 63: 'Rain', 65: 'Heavy rain',
  66: 'Light freezing rain', 67: 'Freezing rain',
  71: 'Light snow', 73: 'Snow', 75: 'Heavy snow', 77: 'Snow grains',
  80: 'Light showers', 81: 'Showers', 82: 'Heavy showers',
  85: 'Light snow showers', 86: 'Heavy snow showers',
  95: 'Thunderstorm', 96: 'Thunderstorm w/ hail', 99: 'Severe thunderstorm',
};

function wmoDescription(code: number): string {
  return WMO_CODES[code] ?? `Unknown (${code})`;
}

function fetchOpenMeteo(location: string): string {
  // Step 1: Geocode city name â†’ lat/lon
  const geoRaw = execFileSync('/usr/bin/curl', [
    '-s', '--max-time', '5',
    `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(location)}&count=1`,
  ], { encoding: 'utf8', timeout: 8_000 }).trim();

  if (!geoRaw) throw new Error('Empty geocoding response');
  const geo = JSON.parse(geoRaw);
  if (!geo.results?.length) throw new Error(`No geocoding results for "${location}"`);

  const { latitude, longitude, timezone } = geo.results[0];

  // Step 2: Fetch current weather + 3-day forecast
  const url = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}` +
    `&current=temperature_2m,relative_humidity_2m,wind_speed_10m,weather_code` +
    `&daily=weather_code,temperature_2m_max,temperature_2m_min,precipitation_probability_max` +
    `&temperature_unit=fahrenheit&wind_speed_unit=mph` +
    `&timezone=${encodeURIComponent(timezone)}&forecast_days=3`;

  const raw = execFileSync('/usr/bin/curl', [
    '-s', '--max-time', '8', url,
  ], { encoding: 'utf8', timeout: 12_000 }).trim();

  if (!raw) throw new Error('Empty forecast response');
  const data = JSON.parse(raw);

  // Format current conditions
  const c = data.current;
  const current = `Now: ${wmoDescription(c.weather_code)}, ${Math.round(c.temperature_2m)}Â°F | Humidity: ${c.relative_humidity_2m}% | Wind: ${Math.round(c.wind_speed_10m)} mph`;

  // Format 3-day forecast
  const days = data.daily;
  const dayNames = ['Today', 'Tomorrow'];
  const forecastLines: string[] = [];
  for (let i = 0; i < days.time.length; i++) {
    const label = dayNames[i] ?? new Date(days.time[i] + 'T12:00:00').toLocaleDateString('en-US', { weekday: 'short' });
    const hi = Math.round(days.temperature_2m_max[i]);
    const lo = Math.round(days.temperature_2m_min[i]);
    const precip = days.precipitation_probability_max[i];
    const desc = wmoDescription(days.weather_code[i]);
    forecastLines.push(`${label}: ${desc}, ${hi}Â°/${lo}Â°F${precip > 10 ? `, ${precip}% precip` : ''}`);
  }

  return `${current}\n${forecastLines.join(' | ')}`;
}

function fetchWttrIn(location: string): string {
  const locationPath = location ? `/${location.replace(/\s+/g, '+')}` : '';

  const current = execFileSync('/usr/bin/curl', [
    '-s', '--max-time', '8',
    `wttr.in${locationPath}?format=%c+%t+|+Humidity:+%h+|+Wind:+%w+|+Precip:+%p`,
  ], { encoding: 'utf8', timeout: 10_000 }).trim();

  const forecast = execFileSync('/usr/bin/curl', [
    '-s', '--max-time', '8',
    `wttr.in${locationPath}?format=3`,
  ], { encoding: 'utf8', timeout: 10_000 }).trim();

  if (!current && !forecast) throw new Error('Both wttr.in requests returned empty');
  const parts = [];
  if (current) parts.push(`Now: ${current}`);
  if (forecast) parts.push(`Forecast: ${forecast}`);
  return parts.join('\n');
}

function gatherWeather(): string {
  const config = loadConfig();
  const task = config.scheduler.tasks.find(t => t.name === 'morning-briefing');
  const location = (task?.config?.weather_location as string) ?? 'Baltimore';

  // Primary: Open-Meteo (reliable 24/7, free, no API key)
  try {
    return fetchOpenMeteo(location);
  } catch (err) {
    log.warn('Open-Meteo failed, trying wttr.in fallback', { error: err instanceof Error ? err.message : String(err) });
  }

  // Fallback: wttr.in (can be flaky overnight)
  try {
    return fetchWttrIn(location);
  } catch (err) {
    log.warn('wttr.in also failed', { error: err instanceof Error ? err.message : String(err) });
    return 'Weather unavailable.';
  }
}

function gatherLookahead(): string {
  try {
    // Compute explicit date range to avoid icalbuddy's -n flag including today
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    const end = new Date();
    end.setDate(end.getDate() + 7);
    const fmt = (d: Date) => d.toISOString().slice(0, 10);

    const output = execSync(
      `icalbuddy -nc -nrd -npn -ea -eep notes,url -df "%A, %b %e, %Y" -b "â€¢ " -iep title,datetime eventsFrom:"${fmt(tomorrow)}" to:"${fmt(end)}"`,
      { encoding: 'utf8', timeout: 10_000 },
    ).trim();
    return output || 'Nothing notable in the next 7 days.';
  } catch {
    log.warn('icalbuddy lookahead failed');
    return 'Lookahead unavailable.';
  }
}

function gatherInternalCalendar(): string {
  const calFile = path.join(getProjectDir(), '.claude/state/calendar.md');
  try {
    if (!fs.existsSync(calFile)) return '';

    const content = fs.readFileSync(calFile, 'utf8');
    // Use local date strings (calendar.md uses local dates, not UTC)
    const now = new Date();
    const todayParts = [now.getFullYear(), String(now.getMonth() + 1).padStart(2, '0'), String(now.getDate()).padStart(2, '0')];
    const today = todayParts.join('-');
    const tmrw = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
    const tmrwParts = [tmrw.getFullYear(), String(tmrw.getMonth() + 1).padStart(2, '0'), String(tmrw.getDate()).padStart(2, '0')];
    const tomorrow = tmrwParts.join('-');

    const entries: string[] = [];
    let currentDate = '';

    for (const line of content.split('\n')) {
      // Match date headings like "### 2026-02-14"
      const dateMatch = line.match(/^###\s+(\d{4}-\d{2}-\d{2})/);
      if (dateMatch) {
        currentDate = dateMatch[1];
        continue;
      }
      // Match entries (- items) under today or tomorrow
      if ((currentDate === today || currentDate === tomorrow) && line.match(/^- /)) {
        const label = currentDate === today ? 'Today' : 'Tomorrow';
        entries.push(`[${label}] ${line.replace(/^- /, '').trim()}`);
      }
    }

    return entries.length > 0 ? entries.join('\n') : '';
  } catch {
    return '';
  }
}

function gatherTodos(): string {
  const todoDir = path.join(getProjectDir(), '.claude/state/todos');
  try {
    const files = fs.readdirSync(todoDir).filter(f => f.endsWith('.json') && !f.includes('-completed-'));
    if (files.length === 0) return 'No open to-dos.';

    const todos: string[] = [];
    for (const file of files) {
      try {
        const data = JSON.parse(fs.readFileSync(path.join(todoDir, file), 'utf8'));
        const priority = (data.priority ?? 'medium').toUpperCase();
        const due = data.due ? ` (due: ${data.due})` : '';
        todos.push(`[${data.id}] ${priority} â€” ${data.title}${due}`);
      } catch {
        // skip malformed files
      }
    }
    return todos.length > 0 ? todos.join('\n') : 'No open to-dos.';
  } catch {
    return 'To-do list unavailable.';
  }
}

function gatherOvernightMessages(): string {
  const logPath = path.join(getProjectDir(), 'logs/daemon.log');
  try {
    if (!fs.existsSync(logPath)) return 'No overnight messages.';

    const now = Date.now();
    const eightHoursAgo = now - 8 * 60 * 60 * 1000;
    const lines = fs.readFileSync(logPath, 'utf8').split('\n');

    const messages: string[] = [];
    for (const line of lines) {
      if (!line) continue;
      try {
        const entry = JSON.parse(line);
        const ts = new Date(entry.ts).getTime();
        if (ts < eightHoursAgo) continue;

        // Telegram incoming messages
        if (entry.module === 'telegram' && entry.msg?.includes('Injected message from')) {
          messages.push(`Telegram: ${entry.msg}`);
        }
        // Agent comms incoming
        if (entry.module === 'agent-comms' && entry.msg?.includes('Received message from')) {
          messages.push(`Agent: ${entry.msg}`);
        }
        // Emails received
        if (entry.module === 'email-check' && entry.msg?.includes('unread')) {
          messages.push(`Email: ${entry.msg}`);
        }
      } catch {
        // skip non-JSON lines
      }
    }

    if (messages.length === 0) return 'No overnight messages.';
    // Deduplicate and limit
    const unique = [...new Set(messages)];
    return unique.slice(-10).join('\n');
  } catch {
    return 'Message log unavailable.';
  }
}

/**
 * Send a plain-text briefing directly via Telegram (no Claude session needed).
 */
function sendDirectTelegram(text: string): void {
  try {
    sendTelegramMessage(text);
    log.info('Sent briefing directly via Telegram (no session fallback)');
  } catch (err) {
    log.error('Failed to send Telegram fallback', {
      error: err instanceof Error ? err.message : String(err),
    });
  }
}

/**
 * Format a plain-text briefing for direct Telegram delivery.
 */
function formatPlainBriefing(today: string, weather: string, calendar: string, internalCal: string, lookahead: string, todos: string, overnight: string, emailSummary: string, specialDay?: string | null): string {
  const greeting = specialDay
    ? `${specialDay}\nGood morning! Here's your briefing for ${today}.`
    : `Good morning! Here's your briefing for ${today}.`;
  const lines = [
    greeting,
    '',
    `Weather:`,
    weather,
    '',
    'Today:',
    calendar,
  ];

  if (internalCal) {
    lines.push('', 'Reminders:', internalCal);
  }

  if (lookahead && !lookahead.includes('Nothing notable') && !lookahead.includes('unavailable')) {
    lines.push('', 'Coming up:', lookahead);
  }

  lines.push('', 'Open to-dos:', todos);

  if (emailSummary && emailSummary !== 'No unread emails.') {
    lines.push('', 'Email:', emailSummary);
  }

  if (overnight && overnight !== 'No overnight messages.') {
    lines.push('', 'Overnight:', overnight);
  }

  return lines.join('\n');
}

async function gatherEmailSummary(): Promise<string> {
  try {
    const results = await checkAllUnread();
    const emails: string[] = [];
    let totalUnread = 0;

    for (const result of results) {
      for (const msg of result.messages) {
        totalUnread++;
        emails.push(`[${result.provider}] ${msg.from}: ${msg.subject}`);
      }
    }

    if (totalUnread === 0) return 'No unread emails.';
    return `${totalUnread} unread email(s):\n${emails.slice(0, 10).join('\n')}${totalUnread > 10 ? `\n...and ${totalUnread - 10} more` : ''}`;
  } catch (err) {
    log.warn('Email summary failed', { error: err instanceof Error ? err.message : String(err) });
    return 'Email summary unavailable.';
  }
}

async function run(): Promise<void> {
  log.info('Gathering morning briefing data');

  const calendar = gatherCalendar();
  const weather = gatherWeather();
  const lookahead = gatherLookahead();
  const internalCal = gatherInternalCalendar();
  const todos = gatherTodos();
  const overnight = gatherOvernightMessages();
  const emailSummary = await gatherEmailSummary();
  const specialDay = getSpecialDayNote();

  const today = new Date().toLocaleDateString('en-US', {
    weekday: 'long',
    month: 'long',
    day: 'numeric',
    year: 'numeric',
  });

  // If a Claude session is running, inject as a prompt for a nicely formatted briefing
  if (sessionExists()) {
    const prompt = [
      `[System] Morning briefing time! Today is ${today}.`,
      'Send the human a concise, friendly morning briefing via Telegram with the data below.',
      'Format it nicely but keep it short â€” a snapshot, not an essay.',
      'Include any notable items and a cheerful greeting.',
      'If the lookahead has anything notable (birthdays, travel, big storms, deadlines), call it out.',
      'IMPORTANT: Calendar data includes day-of-week labels (e.g. "Thursday, Feb 12"). Use those labels exactly â€” do NOT compute day names from dates yourself.',
      ...(specialDay ? ['', `SPECIAL DAY: ${specialDay}`, 'Weave this into your greeting naturally â€” make it feel warm and personal, not just tacked on.'] : []),
      '',
      `WEATHER:\n${weather}`,
      '',
      `CALENDAR:\n${calendar}`,
      ...(internalCal ? ['', `ASSISTANT REMINDERS:\n${internalCal}`] : []),
      '',
      `COMING UP (next 7 days):\n${lookahead}`,
      '',
      `OPEN TO-DOS:\n${todos}`,
      '',
      `OVERNIGHT MESSAGES:\n${overnight}`,
      '',
      `EMAIL INBOX:\n${emailSummary}`,
    ].join('\n');

    log.info('Injecting morning briefing prompt');
    injectText(prompt);
  } else {
    // No session â€” send a plain-text briefing directly via Telegram
    log.warn('No Claude session available â€” sending plain-text briefing via Telegram');
    const briefing = formatPlainBriefing(today, weather, calendar, internalCal, lookahead, todos, overnight, emailSummary, specialDay);
    sendDirectTelegram(briefing);
  }
}

registerTask({ name: 'morning-briefing', run, requiresSession: false });
