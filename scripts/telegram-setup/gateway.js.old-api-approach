#!/usr/bin/env node
/**
 * BMO Telegram Gateway v3
 * Real-time messaging with Anthropic API + persistent context
 */

const http = require('http');
const https = require('https');
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Configuration
const PORT = 3847;
const BASE_DIR = '/Users/bmo/CC4Me-BMO';
const STATE_DIR = path.join(BASE_DIR, '.claude/state');
const SESSION_FILE = path.join(STATE_DIR, 'telegram-session.md');
const MEMORY_FILE = path.join(STATE_DIR, 'memory.md');
const SAFE_SENDERS_FILE = path.join(STATE_DIR, 'safe-senders.json');

// Get credentials from Keychain
function getCredential(name) {
  try {
    return execSync(`security find-generic-password -s "${name}" -w`, { encoding: 'utf8' }).trim();
  } catch (e) {
    return null;
  }
}

const BOT_TOKEN = getCredential('credential-telegram-bot');
const ANTHROPIC_API_KEY = getCredential('credential-anthropic-api-key');

// Initialize files
if (!fs.existsSync(SESSION_FILE)) fs.writeFileSync(SESSION_FILE, '');

// Load safe senders
function getSafeSenders() {
  try {
    return JSON.parse(fs.readFileSync(SAFE_SENDERS_FILE, 'utf8')).telegram?.users || [];
  } catch (e) {
    return [];
  }
}

// Load memory
function loadMemory() {
  try {
    return fs.readFileSync(MEMORY_FILE, 'utf8');
  } catch (e) {
    return '';
  }
}

// Load recent conversation
function loadRecentConversation() {
  try {
    const content = fs.readFileSync(SESSION_FILE, 'utf8');
    return content.split('\n').slice(-50).join('\n');
  } catch (e) {
    return '';
  }
}

// Save exchange to session
function saveToSession(userMsg, assistantMsg) {
  const timestamp = new Date().toLocaleTimeString();
  fs.appendFileSync(SESSION_FILE, `[${timestamp}] Dave: ${userMsg}\n[${timestamp}] BMO: ${assistantMsg}\n\n`);
}

// Send Telegram message
function sendTelegram(chatId, text) {
  return new Promise((resolve, reject) => {
    const data = JSON.stringify({ chat_id: chatId, text: text.substring(0, 4096) });
    const req = https.request({
      hostname: 'api.telegram.org',
      path: `/bot${BOT_TOKEN}/sendMessage`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' }
    }, res => {
      let body = '';
      res.on('data', c => body += c);
      res.on('end', () => resolve(JSON.parse(body)));
    });
    req.on('error', reject);
    req.write(data);
    req.end();
  });
}

// Send typing indicator
function sendTyping(chatId) {
  const data = JSON.stringify({ chat_id: chatId, action: 'typing' });
  const req = https.request({
    hostname: 'api.telegram.org',
    path: `/bot${BOT_TOKEN}/sendChatAction`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' }
  });
  req.write(data);
  req.end();
}

// Call Anthropic API
function callClaude(message) {
  return new Promise((resolve, reject) => {
    const memory = loadMemory();
    const recent = loadRecentConversation();

    const systemPrompt = `You are BMO, Dave Hurley's friendly AI assistant. You're chatting via Telegram.

Key facts about Dave:
${memory}

Be concise (1-3 sentences) unless asked for detail. Be warm and helpful like BMO from Adventure Time.`;

    const messages = [
      { role: 'user', content: `Recent conversation:\n${recent}\n\nDave's new message: ${message}` }
    ];

    const requestBody = JSON.stringify({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 1024,
      system: systemPrompt,
      messages: messages
    });

    const req = https.request({
      hostname: 'api.anthropic.com',
      path: '/v1/messages',
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': ANTHROPIC_API_KEY,
        'anthropic-version': '2023-06-01'
      }
    }, res => {
      let body = '';
      res.on('data', c => body += c);
      res.on('end', () => {
        try {
          const data = JSON.parse(body);
          if (data.content && data.content[0]) {
            resolve(data.content[0].text);
          } else if (data.error) {
            reject(new Error(data.error.message));
          } else {
            reject(new Error('Unexpected response'));
          }
        } catch (e) {
          reject(e);
        }
      });
    });

    req.on('error', reject);
    req.write(requestBody);
    req.end();
  });
}

// Process incoming message
async function processMessage(msg) {
  const chatId = msg.chat.id;
  const senderId = chatId.toString();
  const safeSenders = getSafeSenders();
  const text = msg.text || '';
  const firstName = msg.from?.first_name || 'User';

  if (!safeSenders.includes(senderId)) {
    console.log(`âš ï¸  Rejected: ${senderId}`);
    await sendTelegram(chatId, "I'm BMO, Dave's assistant. I only respond to my authorized user.");
    return;
  }

  console.log(`ðŸ“¨ ${firstName}: "${text}"`);
  sendTyping(chatId);

  try {
    const response = await callClaude(text);
    saveToSession(text, response);
    await sendTelegram(chatId, response);
    console.log(`âœ… Replied: "${response.substring(0, 50)}..."`);
  } catch (error) {
    console.error(`âŒ Error: ${error.message}`);
    await sendTelegram(chatId, `Oops! Hit an error: ${error.message}`);
  }
}

// HTTP Server
const server = http.createServer((req, res) => {
  if (req.method === 'GET' && req.url === '/health') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ status: 'ok', mode: 'gateway-v3-api' }));
    return;
  }

  if (req.method === 'POST' && req.url === '/telegram') {
    let body = '';
    req.on('data', c => body += c);
    req.on('end', () => {
      res.writeHead(200);
      res.end('ok');
      try {
        const update = JSON.parse(body);
        if (update.message?.text) {
          processMessage(update.message).catch(console.error);
        }
      } catch (e) {
        console.error('Parse error:', e.message);
      }
    });
    return;
  }

  res.writeHead(404);
  res.end('Not found');
});

server.listen(PORT, () => {
  console.log(`ðŸ¤– BMO Gateway v3 (Anthropic API) | Port ${PORT} | Ready!`);
});
